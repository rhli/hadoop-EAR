#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def setInactivityTimeoutPeriod(self, periodInSeconds):
    """
    Parameters:
     - periodInSeconds
    """
    pass

  def shutdown(self, status):
    """
    Parameters:
     - status
    """
    pass

  def create(self, path):
    """
    Parameters:
     - path
    """
    pass

  def createFile(self, path, mode, overwrite, bufferSize, block_replication, blocksize):
    """
    Parameters:
     - path
     - mode
     - overwrite
     - bufferSize
     - block_replication
     - blocksize
    """
    pass

  def open(self, path):
    """
    Parameters:
     - path
    """
    pass

  def append(self, path):
    """
    Parameters:
     - path
    """
    pass

  def write(self, handle, data):
    """
    Parameters:
     - handle
     - data
    """
    pass

  def read(self, handle, offset, size):
    """
    Parameters:
     - handle
     - offset
     - size
    """
    pass

  def close(self, out):
    """
    Parameters:
     - out
    """
    pass

  def rm(self, path, recursive):
    """
    Parameters:
     - path
     - recursive
    """
    pass

  def rename(self, path, dest):
    """
    Parameters:
     - path
     - dest
    """
    pass

  def mkdirs(self, path):
    """
    Parameters:
     - path
    """
    pass

  def exists(self, path):
    """
    Parameters:
     - path
    """
    pass

  def stat(self, path):
    """
    Parameters:
     - path
    """
    pass

  def listStatus(self, path):
    """
    Parameters:
     - path
    """
    pass

  def chmod(self, path, mode):
    """
    Parameters:
     - path
     - mode
    """
    pass

  def chown(self, path, owner, group):
    """
    Parameters:
     - path
     - owner
     - group
    """
    pass

  def setReplication(self, path, replication):
    """
    Parameters:
     - path
     - replication
    """
    pass

  def getFileBlockLocations(self, path, start, length):
    """
    Parameters:
     - path
     - start
     - length
    """
    pass

  def hardLink(self, src, dest):
    """
    Parameters:
     - src
     - dest
    """
    pass

  def concat(self, target, srcs, restricted):
    """
    Parameters:
     - target
     - srcs
     - restricted
    """
    pass

  def reportBadBlocks(self, blocks):
    """
    Parameters:
     - blocks
    """
    pass

  def getDataTransferProtocolVersion(self, ):
    """
    The following methods are typically used by native C++ hdfs client and
    are not used by hdfs applications themselves
    """
    pass

  def renewLease(self, clientName):
    """
    Parameters:
     - clientName
    """
    pass

  def recoverLease(self, path, clientName):
    """
    Parameters:
     - path
     - clientName
    """
    pass

  def closeRecoverLease(self, path, clientName, discardLastBlock):
    """
    Parameters:
     - path
     - clientName
     - discardLastBlock
    """
    pass

  def abandonBlock(self, block, pathname, clientName):
    """
    Parameters:
     - block
     - pathname
     - clientName
    """
    pass

  def abandonFile(self, pathname, clientName):
    """
    Parameters:
     - pathname
     - clientName
    """
    pass

  def addBlock(self, pathname, clientName, startOffset, lastBlock, excludedNodes, favouredNodes):
    """
    Parameters:
     - pathname
     - clientName
     - startOffset
     - lastBlock
     - excludedNodes
     - favouredNodes
    """
    pass

  def addFirstBlock(self, pathname, clientName, excludedNodes, favouredNodes):
    """
    Parameters:
     - pathname
     - clientName
     - excludedNodes
     - favouredNodes
    """
    pass

  def complete(self, pathname, clientName, fileLen, lastBlock):
    """
    Parameters:
     - pathname
     - clientName
     - fileLen
     - lastBlock
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def setInactivityTimeoutPeriod(self, periodInSeconds):
    """
    Parameters:
     - periodInSeconds
    """
    self.send_setInactivityTimeoutPeriod(periodInSeconds)
    self.recv_setInactivityTimeoutPeriod()

  def send_setInactivityTimeoutPeriod(self, periodInSeconds):
    self._oprot.writeMessageBegin('setInactivityTimeoutPeriod', TMessageType.CALL, self._seqid)
    args = setInactivityTimeoutPeriod_args()
    args.periodInSeconds = periodInSeconds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setInactivityTimeoutPeriod(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setInactivityTimeoutPeriod_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def shutdown(self, status):
    """
    Parameters:
     - status
    """
    self.send_shutdown(status)
    self.recv_shutdown()

  def send_shutdown(self, status):
    self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
    args = shutdown_args()
    args.status = status
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shutdown(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shutdown_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def create(self, path):
    """
    Parameters:
     - path
    """
    self.send_create(path)
    return self.recv_create()

  def send_create(self, path):
    self._oprot.writeMessageBegin('create', TMessageType.CALL, self._seqid)
    args = create_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create failed: unknown result");

  def createFile(self, path, mode, overwrite, bufferSize, block_replication, blocksize):
    """
    Parameters:
     - path
     - mode
     - overwrite
     - bufferSize
     - block_replication
     - blocksize
    """
    self.send_createFile(path, mode, overwrite, bufferSize, block_replication, blocksize)
    return self.recv_createFile()

  def send_createFile(self, path, mode, overwrite, bufferSize, block_replication, blocksize):
    self._oprot.writeMessageBegin('createFile', TMessageType.CALL, self._seqid)
    args = createFile_args()
    args.path = path
    args.mode = mode
    args.overwrite = overwrite
    args.bufferSize = bufferSize
    args.block_replication = block_replication
    args.blocksize = blocksize
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createFile(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createFile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createFile failed: unknown result");

  def open(self, path):
    """
    Parameters:
     - path
    """
    self.send_open(path)
    return self.recv_open()

  def send_open(self, path):
    self._oprot.writeMessageBegin('open', TMessageType.CALL, self._seqid)
    args = open_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = open_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "open failed: unknown result");

  def append(self, path):
    """
    Parameters:
     - path
    """
    self.send_append(path)
    return self.recv_append()

  def send_append(self, path):
    self._oprot.writeMessageBegin('append', TMessageType.CALL, self._seqid)
    args = append_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append failed: unknown result");

  def write(self, handle, data):
    """
    Parameters:
     - handle
     - data
    """
    self.send_write(handle, data)
    return self.recv_write()

  def send_write(self, handle, data):
    self._oprot.writeMessageBegin('write', TMessageType.CALL, self._seqid)
    args = write_args()
    args.handle = handle
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_write(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = write_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "write failed: unknown result");

  def read(self, handle, offset, size):
    """
    Parameters:
     - handle
     - offset
     - size
    """
    self.send_read(handle, offset, size)
    return self.recv_read()

  def send_read(self, handle, offset, size):
    self._oprot.writeMessageBegin('read', TMessageType.CALL, self._seqid)
    args = read_args()
    args.handle = handle
    args.offset = offset
    args.size = size
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_read(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = read_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "read failed: unknown result");

  def close(self, out):
    """
    Parameters:
     - out
    """
    self.send_close(out)
    return self.recv_close()

  def send_close(self, out):
    self._oprot.writeMessageBegin('close', TMessageType.CALL, self._seqid)
    args = close_args()
    args.out = out
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_close(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = close_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "close failed: unknown result");

  def rm(self, path, recursive):
    """
    Parameters:
     - path
     - recursive
    """
    self.send_rm(path, recursive)
    return self.recv_rm()

  def send_rm(self, path, recursive):
    self._oprot.writeMessageBegin('rm', TMessageType.CALL, self._seqid)
    args = rm_args()
    args.path = path
    args.recursive = recursive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rm(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rm_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rm failed: unknown result");

  def rename(self, path, dest):
    """
    Parameters:
     - path
     - dest
    """
    self.send_rename(path, dest)
    return self.recv_rename()

  def send_rename(self, path, dest):
    self._oprot.writeMessageBegin('rename', TMessageType.CALL, self._seqid)
    args = rename_args()
    args.path = path
    args.dest = dest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rename_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rename failed: unknown result");

  def mkdirs(self, path):
    """
    Parameters:
     - path
    """
    self.send_mkdirs(path)
    return self.recv_mkdirs()

  def send_mkdirs(self, path):
    self._oprot.writeMessageBegin('mkdirs', TMessageType.CALL, self._seqid)
    args = mkdirs_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mkdirs(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mkdirs_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mkdirs failed: unknown result");

  def exists(self, path):
    """
    Parameters:
     - path
    """
    self.send_exists(path)
    return self.recv_exists()

  def send_exists(self, path):
    self._oprot.writeMessageBegin('exists', TMessageType.CALL, self._seqid)
    args = exists_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_exists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = exists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "exists failed: unknown result");

  def stat(self, path):
    """
    Parameters:
     - path
    """
    self.send_stat(path)
    return self.recv_stat()

  def send_stat(self, path):
    self._oprot.writeMessageBegin('stat', TMessageType.CALL, self._seqid)
    args = stat_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stat failed: unknown result");

  def listStatus(self, path):
    """
    Parameters:
     - path
    """
    self.send_listStatus(path)
    return self.recv_listStatus()

  def send_listStatus(self, path):
    self._oprot.writeMessageBegin('listStatus', TMessageType.CALL, self._seqid)
    args = listStatus_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listStatus failed: unknown result");

  def chmod(self, path, mode):
    """
    Parameters:
     - path
     - mode
    """
    self.send_chmod(path, mode)
    self.recv_chmod()

  def send_chmod(self, path, mode):
    self._oprot.writeMessageBegin('chmod', TMessageType.CALL, self._seqid)
    args = chmod_args()
    args.path = path
    args.mode = mode
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chmod(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = chmod_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def chown(self, path, owner, group):
    """
    Parameters:
     - path
     - owner
     - group
    """
    self.send_chown(path, owner, group)
    self.recv_chown()

  def send_chown(self, path, owner, group):
    self._oprot.writeMessageBegin('chown', TMessageType.CALL, self._seqid)
    args = chown_args()
    args.path = path
    args.owner = owner
    args.group = group
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chown(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = chown_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def setReplication(self, path, replication):
    """
    Parameters:
     - path
     - replication
    """
    self.send_setReplication(path, replication)
    self.recv_setReplication()

  def send_setReplication(self, path, replication):
    self._oprot.writeMessageBegin('setReplication', TMessageType.CALL, self._seqid)
    args = setReplication_args()
    args.path = path
    args.replication = replication
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setReplication(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setReplication_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def getFileBlockLocations(self, path, start, length):
    """
    Parameters:
     - path
     - start
     - length
    """
    self.send_getFileBlockLocations(path, start, length)
    return self.recv_getFileBlockLocations()

  def send_getFileBlockLocations(self, path, start, length):
    self._oprot.writeMessageBegin('getFileBlockLocations', TMessageType.CALL, self._seqid)
    args = getFileBlockLocations_args()
    args.path = path
    args.start = start
    args.length = length
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFileBlockLocations(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFileBlockLocations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFileBlockLocations failed: unknown result");

  def hardLink(self, src, dest):
    """
    Parameters:
     - src
     - dest
    """
    self.send_hardLink(src, dest)
    return self.recv_hardLink()

  def send_hardLink(self, src, dest):
    self._oprot.writeMessageBegin('hardLink', TMessageType.CALL, self._seqid)
    args = hardLink_args()
    args.src = src
    args.dest = dest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_hardLink(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = hardLink_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "hardLink failed: unknown result");

  def concat(self, target, srcs, restricted):
    """
    Parameters:
     - target
     - srcs
     - restricted
    """
    self.send_concat(target, srcs, restricted)
    self.recv_concat()

  def send_concat(self, target, srcs, restricted):
    self._oprot.writeMessageBegin('concat', TMessageType.CALL, self._seqid)
    args = concat_args()
    args.target = target
    args.srcs = srcs
    args.restricted = restricted
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_concat(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = concat_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def reportBadBlocks(self, blocks):
    """
    Parameters:
     - blocks
    """
    self.send_reportBadBlocks(blocks)
    self.recv_reportBadBlocks()

  def send_reportBadBlocks(self, blocks):
    self._oprot.writeMessageBegin('reportBadBlocks', TMessageType.CALL, self._seqid)
    args = reportBadBlocks_args()
    args.blocks = blocks
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reportBadBlocks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = reportBadBlocks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def getDataTransferProtocolVersion(self, ):
    """
    The following methods are typically used by native C++ hdfs client and
    are not used by hdfs applications themselves
    """
    self.send_getDataTransferProtocolVersion()
    return self.recv_getDataTransferProtocolVersion()

  def send_getDataTransferProtocolVersion(self, ):
    self._oprot.writeMessageBegin('getDataTransferProtocolVersion', TMessageType.CALL, self._seqid)
    args = getDataTransferProtocolVersion_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataTransferProtocolVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDataTransferProtocolVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataTransferProtocolVersion failed: unknown result");

  def renewLease(self, clientName):
    """
    Parameters:
     - clientName
    """
    self.send_renewLease(clientName)
    self.recv_renewLease()

  def send_renewLease(self, clientName):
    self._oprot.writeMessageBegin('renewLease', TMessageType.CALL, self._seqid)
    args = renewLease_args()
    args.clientName = clientName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renewLease(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = renewLease_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def recoverLease(self, path, clientName):
    """
    Parameters:
     - path
     - clientName
    """
    self.send_recoverLease(path, clientName)
    self.recv_recoverLease()

  def send_recoverLease(self, path, clientName):
    self._oprot.writeMessageBegin('recoverLease', TMessageType.CALL, self._seqid)
    args = recoverLease_args()
    args.path = path
    args.clientName = clientName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_recoverLease(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = recoverLease_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def closeRecoverLease(self, path, clientName, discardLastBlock):
    """
    Parameters:
     - path
     - clientName
     - discardLastBlock
    """
    self.send_closeRecoverLease(path, clientName, discardLastBlock)
    self.recv_closeRecoverLease()

  def send_closeRecoverLease(self, path, clientName, discardLastBlock):
    self._oprot.writeMessageBegin('closeRecoverLease', TMessageType.CALL, self._seqid)
    args = closeRecoverLease_args()
    args.path = path
    args.clientName = clientName
    args.discardLastBlock = discardLastBlock
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_closeRecoverLease(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = closeRecoverLease_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def abandonBlock(self, block, pathname, clientName):
    """
    Parameters:
     - block
     - pathname
     - clientName
    """
    self.send_abandonBlock(block, pathname, clientName)
    self.recv_abandonBlock()

  def send_abandonBlock(self, block, pathname, clientName):
    self._oprot.writeMessageBegin('abandonBlock', TMessageType.CALL, self._seqid)
    args = abandonBlock_args()
    args.block = block
    args.pathname = pathname
    args.clientName = clientName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abandonBlock(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = abandonBlock_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def abandonFile(self, pathname, clientName):
    """
    Parameters:
     - pathname
     - clientName
    """
    self.send_abandonFile(pathname, clientName)
    self.recv_abandonFile()

  def send_abandonFile(self, pathname, clientName):
    self._oprot.writeMessageBegin('abandonFile', TMessageType.CALL, self._seqid)
    args = abandonFile_args()
    args.pathname = pathname
    args.clientName = clientName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abandonFile(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = abandonFile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ouch is not None:
      raise result.ouch
    return

  def addBlock(self, pathname, clientName, startOffset, lastBlock, excludedNodes, favouredNodes):
    """
    Parameters:
     - pathname
     - clientName
     - startOffset
     - lastBlock
     - excludedNodes
     - favouredNodes
    """
    self.send_addBlock(pathname, clientName, startOffset, lastBlock, excludedNodes, favouredNodes)
    return self.recv_addBlock()

  def send_addBlock(self, pathname, clientName, startOffset, lastBlock, excludedNodes, favouredNodes):
    self._oprot.writeMessageBegin('addBlock', TMessageType.CALL, self._seqid)
    args = addBlock_args()
    args.pathname = pathname
    args.clientName = clientName
    args.startOffset = startOffset
    args.lastBlock = lastBlock
    args.excludedNodes = excludedNodes
    args.favouredNodes = favouredNodes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addBlock(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addBlock_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addBlock failed: unknown result");

  def addFirstBlock(self, pathname, clientName, excludedNodes, favouredNodes):
    """
    Parameters:
     - pathname
     - clientName
     - excludedNodes
     - favouredNodes
    """
    self.send_addFirstBlock(pathname, clientName, excludedNodes, favouredNodes)
    return self.recv_addFirstBlock()

  def send_addFirstBlock(self, pathname, clientName, excludedNodes, favouredNodes):
    self._oprot.writeMessageBegin('addFirstBlock', TMessageType.CALL, self._seqid)
    args = addFirstBlock_args()
    args.pathname = pathname
    args.clientName = clientName
    args.excludedNodes = excludedNodes
    args.favouredNodes = favouredNodes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addFirstBlock(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addFirstBlock_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addFirstBlock failed: unknown result");

  def complete(self, pathname, clientName, fileLen, lastBlock):
    """
    Parameters:
     - pathname
     - clientName
     - fileLen
     - lastBlock
    """
    self.send_complete(pathname, clientName, fileLen, lastBlock)
    return self.recv_complete()

  def send_complete(self, pathname, clientName, fileLen, lastBlock):
    self._oprot.writeMessageBegin('complete', TMessageType.CALL, self._seqid)
    args = complete_args()
    args.pathname = pathname
    args.clientName = clientName
    args.fileLen = fileLen
    args.lastBlock = lastBlock
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_complete(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = complete_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ouch is not None:
      raise result.ouch
    raise TApplicationException(TApplicationException.MISSING_RESULT, "complete failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["setInactivityTimeoutPeriod"] = Processor.process_setInactivityTimeoutPeriod
    self._processMap["shutdown"] = Processor.process_shutdown
    self._processMap["create"] = Processor.process_create
    self._processMap["createFile"] = Processor.process_createFile
    self._processMap["open"] = Processor.process_open
    self._processMap["append"] = Processor.process_append
    self._processMap["write"] = Processor.process_write
    self._processMap["read"] = Processor.process_read
    self._processMap["close"] = Processor.process_close
    self._processMap["rm"] = Processor.process_rm
    self._processMap["rename"] = Processor.process_rename
    self._processMap["mkdirs"] = Processor.process_mkdirs
    self._processMap["exists"] = Processor.process_exists
    self._processMap["stat"] = Processor.process_stat
    self._processMap["listStatus"] = Processor.process_listStatus
    self._processMap["chmod"] = Processor.process_chmod
    self._processMap["chown"] = Processor.process_chown
    self._processMap["setReplication"] = Processor.process_setReplication
    self._processMap["getFileBlockLocations"] = Processor.process_getFileBlockLocations
    self._processMap["hardLink"] = Processor.process_hardLink
    self._processMap["concat"] = Processor.process_concat
    self._processMap["reportBadBlocks"] = Processor.process_reportBadBlocks
    self._processMap["getDataTransferProtocolVersion"] = Processor.process_getDataTransferProtocolVersion
    self._processMap["renewLease"] = Processor.process_renewLease
    self._processMap["recoverLease"] = Processor.process_recoverLease
    self._processMap["closeRecoverLease"] = Processor.process_closeRecoverLease
    self._processMap["abandonBlock"] = Processor.process_abandonBlock
    self._processMap["abandonFile"] = Processor.process_abandonFile
    self._processMap["addBlock"] = Processor.process_addBlock
    self._processMap["addFirstBlock"] = Processor.process_addFirstBlock
    self._processMap["complete"] = Processor.process_complete

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_setInactivityTimeoutPeriod(self, seqid, iprot, oprot):
    args = setInactivityTimeoutPeriod_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setInactivityTimeoutPeriod_result()
    self._handler.setInactivityTimeoutPeriod(args.periodInSeconds)
    oprot.writeMessageBegin("setInactivityTimeoutPeriod", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shutdown(self, seqid, iprot, oprot):
    args = shutdown_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shutdown_result()
    self._handler.shutdown(args.status)
    oprot.writeMessageBegin("shutdown", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create(self, seqid, iprot, oprot):
    args = create_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_result()
    try:
      result.success = self._handler.create(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("create", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createFile(self, seqid, iprot, oprot):
    args = createFile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createFile_result()
    try:
      result.success = self._handler.createFile(args.path, args.mode, args.overwrite, args.bufferSize, args.block_replication, args.blocksize)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("createFile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_open(self, seqid, iprot, oprot):
    args = open_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = open_result()
    try:
      result.success = self._handler.open(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("open", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append(self, seqid, iprot, oprot):
    args = append_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_result()
    try:
      result.success = self._handler.append(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("append", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_write(self, seqid, iprot, oprot):
    args = write_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = write_result()
    try:
      result.success = self._handler.write(args.handle, args.data)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("write", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_read(self, seqid, iprot, oprot):
    args = read_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = read_result()
    try:
      result.success = self._handler.read(args.handle, args.offset, args.size)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("read", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_close(self, seqid, iprot, oprot):
    args = close_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = close_result()
    try:
      result.success = self._handler.close(args.out)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("close", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rm(self, seqid, iprot, oprot):
    args = rm_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rm_result()
    try:
      result.success = self._handler.rm(args.path, args.recursive)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("rm", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename(self, seqid, iprot, oprot):
    args = rename_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_result()
    try:
      result.success = self._handler.rename(args.path, args.dest)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("rename", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mkdirs(self, seqid, iprot, oprot):
    args = mkdirs_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mkdirs_result()
    try:
      result.success = self._handler.mkdirs(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("mkdirs", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_exists(self, seqid, iprot, oprot):
    args = exists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = exists_result()
    try:
      result.success = self._handler.exists(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("exists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stat(self, seqid, iprot, oprot):
    args = stat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stat_result()
    try:
      result.success = self._handler.stat(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("stat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listStatus(self, seqid, iprot, oprot):
    args = listStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listStatus_result()
    try:
      result.success = self._handler.listStatus(args.path)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("listStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chmod(self, seqid, iprot, oprot):
    args = chmod_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chmod_result()
    try:
      self._handler.chmod(args.path, args.mode)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("chmod", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chown(self, seqid, iprot, oprot):
    args = chown_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chown_result()
    try:
      self._handler.chown(args.path, args.owner, args.group)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("chown", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setReplication(self, seqid, iprot, oprot):
    args = setReplication_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setReplication_result()
    try:
      self._handler.setReplication(args.path, args.replication)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("setReplication", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFileBlockLocations(self, seqid, iprot, oprot):
    args = getFileBlockLocations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFileBlockLocations_result()
    try:
      result.success = self._handler.getFileBlockLocations(args.path, args.start, args.length)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("getFileBlockLocations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_hardLink(self, seqid, iprot, oprot):
    args = hardLink_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = hardLink_result()
    try:
      result.success = self._handler.hardLink(args.src, args.dest)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("hardLink", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_concat(self, seqid, iprot, oprot):
    args = concat_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = concat_result()
    try:
      self._handler.concat(args.target, args.srcs, args.restricted)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("concat", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reportBadBlocks(self, seqid, iprot, oprot):
    args = reportBadBlocks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reportBadBlocks_result()
    try:
      self._handler.reportBadBlocks(args.blocks)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("reportBadBlocks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataTransferProtocolVersion(self, seqid, iprot, oprot):
    args = getDataTransferProtocolVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataTransferProtocolVersion_result()
    try:
      result.success = self._handler.getDataTransferProtocolVersion()
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("getDataTransferProtocolVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renewLease(self, seqid, iprot, oprot):
    args = renewLease_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renewLease_result()
    try:
      self._handler.renewLease(args.clientName)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("renewLease", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_recoverLease(self, seqid, iprot, oprot):
    args = recoverLease_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = recoverLease_result()
    try:
      self._handler.recoverLease(args.path, args.clientName)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("recoverLease", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeRecoverLease(self, seqid, iprot, oprot):
    args = closeRecoverLease_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeRecoverLease_result()
    try:
      self._handler.closeRecoverLease(args.path, args.clientName, args.discardLastBlock)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("closeRecoverLease", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abandonBlock(self, seqid, iprot, oprot):
    args = abandonBlock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abandonBlock_result()
    try:
      self._handler.abandonBlock(args.block, args.pathname, args.clientName)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("abandonBlock", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_abandonFile(self, seqid, iprot, oprot):
    args = abandonFile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abandonFile_result()
    try:
      self._handler.abandonFile(args.pathname, args.clientName)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("abandonFile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addBlock(self, seqid, iprot, oprot):
    args = addBlock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addBlock_result()
    try:
      result.success = self._handler.addBlock(args.pathname, args.clientName, args.startOffset, args.lastBlock, args.excludedNodes, args.favouredNodes)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("addBlock", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addFirstBlock(self, seqid, iprot, oprot):
    args = addFirstBlock_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addFirstBlock_result()
    try:
      result.success = self._handler.addFirstBlock(args.pathname, args.clientName, args.excludedNodes, args.favouredNodes)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("addFirstBlock", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_complete(self, seqid, iprot, oprot):
    args = complete_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = complete_result()
    try:
      result.success = self._handler.complete(args.pathname, args.clientName, args.fileLen, args.lastBlock)
    except ThriftIOException, ouch:
      result.ouch = ouch
    oprot.writeMessageBegin("complete", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class setInactivityTimeoutPeriod_args:
  """
  Attributes:
   - periodInSeconds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'periodInSeconds', None, None, ), # 1
  )

  def __init__(self, periodInSeconds=None,):
    self.periodInSeconds = periodInSeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.periodInSeconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setInactivityTimeoutPeriod_args')
    if self.periodInSeconds is not None:
      oprot.writeFieldBegin('periodInSeconds', TType.I64, 1)
      oprot.writeI64(self.periodInSeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setInactivityTimeoutPeriod_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setInactivityTimeoutPeriod_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_args:
  """
  Attributes:
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
  )

  def __init__(self, status=None,):
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_args')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ThriftHandle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createFile_args:
  """
  Attributes:
   - path
   - mode
   - overwrite
   - bufferSize
   - block_replication
   - blocksize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.I16, 'mode', None, None, ), # 2
    (3, TType.BOOL, 'overwrite', None, None, ), # 3
    (4, TType.I32, 'bufferSize', None, None, ), # 4
    (5, TType.I16, 'block_replication', None, None, ), # 5
    (6, TType.I64, 'blocksize', None, None, ), # 6
  )

  def __init__(self, path=None, mode=None, overwrite=None, bufferSize=None, block_replication=None, blocksize=None,):
    self.path = path
    self.mode = mode
    self.overwrite = overwrite
    self.bufferSize = bufferSize
    self.block_replication = block_replication
    self.blocksize = blocksize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.mode = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.overwrite = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.bufferSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.block_replication = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.blocksize = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createFile_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I16, 2)
      oprot.writeI16(self.mode)
      oprot.writeFieldEnd()
    if self.overwrite is not None:
      oprot.writeFieldBegin('overwrite', TType.BOOL, 3)
      oprot.writeBool(self.overwrite)
      oprot.writeFieldEnd()
    if self.bufferSize is not None:
      oprot.writeFieldBegin('bufferSize', TType.I32, 4)
      oprot.writeI32(self.bufferSize)
      oprot.writeFieldEnd()
    if self.block_replication is not None:
      oprot.writeFieldBegin('block_replication', TType.I16, 5)
      oprot.writeI16(self.block_replication)
      oprot.writeFieldEnd()
    if self.blocksize is not None:
      oprot.writeFieldBegin('blocksize', TType.I64, 6)
      oprot.writeI64(self.blocksize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createFile_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ThriftHandle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createFile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class open_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ThriftHandle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('open_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ThriftHandle()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_args:
  """
  Attributes:
   - handle
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'handle', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 1
    (2, TType.STRING, 'data', None, None, ), # 2
  )

  def __init__(self, handle=None, data=None,):
    self.handle = handle
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.handle = ThriftHandle()
          self.handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRUCT, 1)
      self.handle.write(oprot)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class write_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('write_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_args:
  """
  Attributes:
   - handle
   - offset
   - size
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'handle', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 1
    (2, TType.I64, 'offset', None, None, ), # 2
    (3, TType.I32, 'size', None, None, ), # 3
  )

  def __init__(self, handle=None, offset=None, size=None,):
    self.handle = handle
    self.offset = offset
    self.size = size

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.handle = ThriftHandle()
          self.handle.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.offset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.size = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRUCT, 1)
      self.handle.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I64, 2)
      oprot.writeI64(self.offset)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I32, 3)
      oprot.writeI32(self.size)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class close_args:
  """
  Attributes:
   - out
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'out', (ThriftHandle, ThriftHandle.thrift_spec), None, ), # 1
  )

  def __init__(self, out=None,):
    self.out = out

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.out = ThriftHandle()
          self.out.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('close_args')
    if self.out is not None:
      oprot.writeFieldBegin('out', TType.STRUCT, 1)
      self.out.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class close_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('close_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_args:
  """
  Attributes:
   - path
   - recursive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'recursive', None, None, ), # 2
  )

  def __init__(self, path=None, recursive=None,):
    self.path = path
    self.recursive = recursive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.recursive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.recursive is not None:
      oprot.writeFieldBegin('recursive', TType.BOOL, 2)
      oprot.writeBool(self.recursive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_args:
  """
  Attributes:
   - path
   - dest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dest', (Pathname, Pathname.thrift_spec), None, ), # 2
  )

  def __init__(self, path=None, dest=None,):
    self.path = path
    self.dest = dest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dest = Pathname()
          self.dest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.dest is not None:
      oprot.writeFieldBegin('dest', TType.STRUCT, 2)
      self.dest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mkdirs_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mkdirs_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mkdirs_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mkdirs_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exists_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class exists_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('exists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stat_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stat_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stat_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (FileStatus, FileStatus.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = FileStatus()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stat_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listStatus_args:
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listStatus_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listStatus_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FileStatus, FileStatus.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = FileStatus()
            _elem26.read(iprot)
            self.success.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter27 in self.success:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chmod_args:
  """
  Attributes:
   - path
   - mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.I16, 'mode', None, None, ), # 2
  )

  def __init__(self, path=None, mode=None,):
    self.path = path
    self.mode = mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.mode = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chmod_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I16, 2)
      oprot.writeI16(self.mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chmod_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chmod_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chown_args:
  """
  Attributes:
   - path
   - owner
   - group
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'owner', None, None, ), # 2
    (3, TType.STRING, 'group', None, None, ), # 3
  )

  def __init__(self, path=None, owner=None, group=None,):
    self.path = path
    self.owner = owner
    self.group = group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.group = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chown_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.owner is not None:
      oprot.writeFieldBegin('owner', TType.STRING, 2)
      oprot.writeString(self.owner)
      oprot.writeFieldEnd()
    if self.group is not None:
      oprot.writeFieldBegin('group', TType.STRING, 3)
      oprot.writeString(self.group)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chown_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chown_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setReplication_args:
  """
  Attributes:
   - path
   - replication
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.I16, 'replication', None, None, ), # 2
  )

  def __init__(self, path=None, replication=None,):
    self.path = path
    self.replication = replication

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.replication = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setReplication_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.replication is not None:
      oprot.writeFieldBegin('replication', TType.I16, 2)
      oprot.writeI16(self.replication)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setReplication_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setReplication_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileBlockLocations_args:
  """
  Attributes:
   - path
   - start
   - length
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'length', None, None, ), # 3
  )

  def __init__(self, path=None, start=None, length=None,):
    self.path = path
    self.start = start
    self.length = length

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.length = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileBlockLocations_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I64, 3)
      oprot.writeI64(self.length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFileBlockLocations_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BlockLocation, BlockLocation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = BlockLocation()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFileBlockLocations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hardLink_args:
  """
  Attributes:
   - src
   - dest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'src', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dest', (Pathname, Pathname.thrift_spec), None, ), # 2
  )

  def __init__(self, src=None, dest=None,):
    self.src = src
    self.dest = dest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Pathname()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dest = Pathname()
          self.dest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hardLink_args')
    if self.src is not None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.dest is not None:
      oprot.writeFieldBegin('dest', TType.STRUCT, 2)
      self.dest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class hardLink_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('hardLink_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class concat_args:
  """
  Attributes:
   - target
   - srcs
   - restricted
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'target', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.LIST, 'srcs', (TType.STRUCT,(Pathname, Pathname.thrift_spec)), None, ), # 2
    (3, TType.BOOL, 'restricted', None, None, ), # 3
  )

  def __init__(self, target=None, srcs=None, restricted=None,):
    self.target = target
    self.srcs = srcs
    self.restricted = restricted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.target = Pathname()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.srcs = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Pathname()
            _elem40.read(iprot)
            self.srcs.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.restricted = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('concat_args')
    if self.target is not None:
      oprot.writeFieldBegin('target', TType.STRUCT, 1)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    if self.srcs is not None:
      oprot.writeFieldBegin('srcs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.srcs))
      for iter41 in self.srcs:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.restricted is not None:
      oprot.writeFieldBegin('restricted', TType.BOOL, 3)
      oprot.writeBool(self.restricted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class concat_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('concat_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reportBadBlocks_args:
  """
  Attributes:
   - blocks
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'blocks', (TType.STRUCT,(TLocatedBlock, TLocatedBlock.thrift_spec)), None, ), # 1
  )

  def __init__(self, blocks=None,):
    self.blocks = blocks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.blocks = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = TLocatedBlock()
            _elem47.read(iprot)
            self.blocks.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reportBadBlocks_args')
    if self.blocks is not None:
      oprot.writeFieldBegin('blocks', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.blocks))
      for iter48 in self.blocks:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reportBadBlocks_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reportBadBlocks_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataTransferProtocolVersion_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataTransferProtocolVersion_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataTransferProtocolVersion_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataTransferProtocolVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renewLease_args:
  """
  Attributes:
   - clientName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientName', None, None, ), # 1
  )

  def __init__(self, clientName=None,):
    self.clientName = clientName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renewLease_args')
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 1)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renewLease_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renewLease_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class recoverLease_args:
  """
  Attributes:
   - path
   - clientName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
  )

  def __init__(self, path=None, clientName=None,):
    self.path = path
    self.clientName = clientName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('recoverLease_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class recoverLease_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('recoverLease_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeRecoverLease_args:
  """
  Attributes:
   - path
   - clientName
   - discardLastBlock
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'path', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
    (3, TType.BOOL, 'discardLastBlock', None, None, ), # 3
  )

  def __init__(self, path=None, clientName=None, discardLastBlock=None,):
    self.path = path
    self.clientName = clientName
    self.discardLastBlock = discardLastBlock

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.path = Pathname()
          self.path.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.discardLastBlock = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeRecoverLease_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRUCT, 1)
      self.path.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.discardLastBlock is not None:
      oprot.writeFieldBegin('discardLastBlock', TType.BOOL, 3)
      oprot.writeBool(self.discardLastBlock)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeRecoverLease_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeRecoverLease_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abandonBlock_args:
  """
  Attributes:
   - block
   - pathname
   - clientName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'block', (TBlock, TBlock.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'pathname', (Pathname, Pathname.thrift_spec), None, ), # 2
    (3, TType.STRING, 'clientName', None, None, ), # 3
  )

  def __init__(self, block=None, pathname=None, clientName=None,):
    self.block = block
    self.pathname = pathname
    self.clientName = clientName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.block = TBlock()
          self.block.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.pathname = Pathname()
          self.pathname.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abandonBlock_args')
    if self.block is not None:
      oprot.writeFieldBegin('block', TType.STRUCT, 1)
      self.block.write(oprot)
      oprot.writeFieldEnd()
    if self.pathname is not None:
      oprot.writeFieldBegin('pathname', TType.STRUCT, 2)
      self.pathname.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 3)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abandonBlock_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abandonBlock_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abandonFile_args:
  """
  Attributes:
   - pathname
   - clientName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pathname', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
  )

  def __init__(self, pathname=None, clientName=None,):
    self.pathname = pathname
    self.clientName = clientName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pathname = Pathname()
          self.pathname.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abandonFile_args')
    if self.pathname is not None:
      oprot.writeFieldBegin('pathname', TType.STRUCT, 1)
      self.pathname.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abandonFile_result:
  """
  Attributes:
   - ouch
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, ouch=None,):
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abandonFile_result')
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addBlock_args:
  """
  Attributes:
   - pathname
   - clientName
   - startOffset
   - lastBlock
   - excludedNodes
   - favouredNodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pathname', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
    (3, TType.I64, 'startOffset', None, None, ), # 3
    (4, TType.STRUCT, 'lastBlock', (TBlock, TBlock.thrift_spec), None, ), # 4
    (5, TType.LIST, 'excludedNodes', (TType.STRUCT,(TDatanodeID, TDatanodeID.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'favouredNodes', (TType.STRUCT,(TDatanodeID, TDatanodeID.thrift_spec)), None, ), # 6
  )

  def __init__(self, pathname=None, clientName=None, startOffset=None, lastBlock=None, excludedNodes=None, favouredNodes=None,):
    self.pathname = pathname
    self.clientName = clientName
    self.startOffset = startOffset
    self.lastBlock = lastBlock
    self.excludedNodes = excludedNodes
    self.favouredNodes = favouredNodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pathname = Pathname()
          self.pathname.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startOffset = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.lastBlock = TBlock()
          self.lastBlock.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.excludedNodes = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = TDatanodeID()
            _elem54.read(iprot)
            self.excludedNodes.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.favouredNodes = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = TDatanodeID()
            _elem60.read(iprot)
            self.favouredNodes.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addBlock_args')
    if self.pathname is not None:
      oprot.writeFieldBegin('pathname', TType.STRUCT, 1)
      self.pathname.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.startOffset is not None:
      oprot.writeFieldBegin('startOffset', TType.I64, 3)
      oprot.writeI64(self.startOffset)
      oprot.writeFieldEnd()
    if self.lastBlock is not None:
      oprot.writeFieldBegin('lastBlock', TType.STRUCT, 4)
      self.lastBlock.write(oprot)
      oprot.writeFieldEnd()
    if self.excludedNodes is not None:
      oprot.writeFieldBegin('excludedNodes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.excludedNodes))
      for iter61 in self.excludedNodes:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.favouredNodes is not None:
      oprot.writeFieldBegin('favouredNodes', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.favouredNodes))
      for iter62 in self.favouredNodes:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addBlock_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TLocatedBlock, TLocatedBlock.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TLocatedBlock()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addBlock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addFirstBlock_args:
  """
  Attributes:
   - pathname
   - clientName
   - excludedNodes
   - favouredNodes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pathname', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
    (3, TType.LIST, 'excludedNodes', (TType.STRUCT,(TDatanodeID, TDatanodeID.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'favouredNodes', (TType.STRUCT,(TDatanodeID, TDatanodeID.thrift_spec)), None, ), # 4
  )

  def __init__(self, pathname=None, clientName=None, excludedNodes=None, favouredNodes=None,):
    self.pathname = pathname
    self.clientName = clientName
    self.excludedNodes = excludedNodes
    self.favouredNodes = favouredNodes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pathname = Pathname()
          self.pathname.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.excludedNodes = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = TDatanodeID()
            _elem68.read(iprot)
            self.excludedNodes.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.favouredNodes = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = TDatanodeID()
            _elem74.read(iprot)
            self.favouredNodes.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addFirstBlock_args')
    if self.pathname is not None:
      oprot.writeFieldBegin('pathname', TType.STRUCT, 1)
      self.pathname.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.excludedNodes is not None:
      oprot.writeFieldBegin('excludedNodes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.excludedNodes))
      for iter75 in self.excludedNodes:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.favouredNodes is not None:
      oprot.writeFieldBegin('favouredNodes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.favouredNodes))
      for iter76 in self.favouredNodes:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addFirstBlock_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TLocatedBlock, TLocatedBlock.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TLocatedBlock()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addFirstBlock_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class complete_args:
  """
  Attributes:
   - pathname
   - clientName
   - fileLen
   - lastBlock
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'pathname', (Pathname, Pathname.thrift_spec), None, ), # 1
    (2, TType.STRING, 'clientName', None, None, ), # 2
    (3, TType.I64, 'fileLen', None, None, ), # 3
    (4, TType.STRUCT, 'lastBlock', (TBlock, TBlock.thrift_spec), None, ), # 4
  )

  def __init__(self, pathname=None, clientName=None, fileLen=None, lastBlock=None,):
    self.pathname = pathname
    self.clientName = clientName
    self.fileLen = fileLen
    self.lastBlock = lastBlock

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.pathname = Pathname()
          self.pathname.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.fileLen = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.lastBlock = TBlock()
          self.lastBlock.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('complete_args')
    if self.pathname is not None:
      oprot.writeFieldBegin('pathname', TType.STRUCT, 1)
      self.pathname.write(oprot)
      oprot.writeFieldEnd()
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 2)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.fileLen is not None:
      oprot.writeFieldBegin('fileLen', TType.I64, 3)
      oprot.writeI64(self.fileLen)
      oprot.writeFieldEnd()
    if self.lastBlock is not None:
      oprot.writeFieldBegin('lastBlock', TType.STRUCT, 4)
      self.lastBlock.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class complete_result:
  """
  Attributes:
   - success
   - ouch
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ouch', (ThriftIOException, ThriftIOException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ouch=None,):
    self.success = success
    self.ouch = ouch

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ouch = ThriftIOException()
          self.ouch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('complete_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ouch is not None:
      oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
      self.ouch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
